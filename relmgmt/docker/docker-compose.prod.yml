# Production Docker Compose Configuration for Release Management System
version: '3.8'

services:
  # Database
  relmgmtpostgres:
    image: postgres:17.5-alpine
    container_name: relmgmt-postgres-prod
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB:-relmgmt}
      # Performance optimizations
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d:ro
    networks:
      - relmgmt-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-relmgmt}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    # Security: run as non-root user
    user: postgres
    # Resource limits
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'

  # Backend API
  relmgmt-backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
      target: runtime
    container_name: relmgmt-backend-prod
    restart: unless-stopped
    environment:
      # Database configuration
      SPRING_DATASOURCE_URL: jdbc:postgresql://relmgmtpostgres:5432/${POSTGRES_DB:-relmgmt}
      SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER:-postgres}
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD}
      
      # Application configuration
      SPRING_PROFILES_ACTIVE: prod
      SERVER_PORT: 8080
      
      # JWT configuration
      APP_JWT_SECRET: ${JWT_SECRET}
      APP_JWT_EXPIRATION: ${JWT_EXPIRATION:-86400000}
      
      # Logging
      LOGGING_LEVEL_ROOT: ${LOG_LEVEL:-INFO}
      LOGGING_LEVEL_COM_POLYCODER_RELMGMT: ${APP_LOG_LEVEL:-INFO}
      
      # Database optimization
      SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE: 10
      SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE: 5
      SPRING_DATASOURCE_HIKARI_IDLE_TIMEOUT: 300000
      SPRING_DATASOURCE_HIKARI_CONNECTION_TIMEOUT: 20000
      
      # JPA configuration
      SPRING_JPA_HIBERNATE_DDL_AUTO: none
      SPRING_JPA_SHOW_SQL: false
      
      # Flyway configuration
      SPRING_FLYWAY_ENABLED: true
      SPRING_FLYWAY_CLEAN_DISABLED: true
      
      # Actuator configuration
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics,prometheus
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: when_authorized
    ports:
      - "${BACKEND_PORT:-8080}:8080"
    networks:
      - relmgmt-network
    depends_on:
      relmgmtpostgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    # Resource limits
    deploy:
      resources:
        limits:
          memory: 1.5G
          cpus: '1.0'
        reservations:
          memory: 768M
          cpus: '0.5'

  # Frontend
  relmgmt-frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
      target: production
      args:
        - VITE_API_URL=${VITE_API_URL:-http://localhost:8080/api}
    container_name: relmgmt-frontend-prod
    restart: unless-stopped
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    networks:
      - relmgmt-network
    depends_on:
      - relmgmt-backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    # Resource limits
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.25'

networks:
  relmgmt-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  postgres_data:
    driver: local
